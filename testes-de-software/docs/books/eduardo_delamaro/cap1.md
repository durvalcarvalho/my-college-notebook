# Capítulo 1 Conceitos Básicos

## 1.1. Introdução

Para que possamos tratar de um assunto tão vasto quanto o proposto neste livro é necessário, primeiro, estabelecer uma linguagem própria. Como acontece em muitas das áreas da Computação e das ciências em geral, termos comuns adquirem significados particulares quando usados tecnicamente.

## 1.2. Validação, Verificação e Testes de Software

Definitivamente, a construção de software não é uma tarefa simples. Pelo contrário, pode se tornar bastante complexa, dependendo das características e dimensões do sistema a ser criado. Por isso, está sujeita a **diversos tipos de problemas** que acabam resultando na obtenção de um produto diferente daquele que se esperava.

Muitos fatores podem ser identificados como causas de tais problemas, mas a maioria deles tem uma única origem: erro humano. Como a maioria das atividades de engenharia, a construção de software depende principalmente da habilidade, da interpretação e da execução das pessoas que o constroem, por isso, erros acabam surgindo, mesmo com a utilização de métodos e ferramentas de engenharia de software.

Para que tais erros não perdurem, ou seja, para serem descobertos antes de o software ser liberado para utilização, existe uma série de atividades, coletivamente chamadas de "Validação, Verificação e Teste" ou "VV&T", com a finalidade de garantir que tanto o modo pelo qual o software está sendo construído quanto o produto em si estejam em conformidade com o especificado.

Atividades de VV&T não se restringem ao produto final. Ao contrário, podem e devem ser conduzidas durante todo o processo de desenvolvimento do software, desde a sua concepção, e englobam diferentes técnicas.

Costumamanos dividir as atividades de VV&T em estáticas e dinâmicas. As estáticas são aquelas que não requerem a execução ou mesmo a existência de um programa ou modelo executável para serem conduzidas. As dinâmicas são aquelas que se baseiam na execução de um programa ou de um modelo.

O objeto principal deste livro é uma atividade dinâmica. Seu intuito é executar o programa ou modelo utilizando algumas entradas em particular e verificar se seu comportamento está de acordo com o esperado.

Outras atividades de VV&T não são tratadas neste texto. São atividades importantes e que permitem a eliminação de erros desde as fases iniciais do processo de desenvolvimento, o que, em geral, representa uma economia significativa de recursos. Alguns exemplos de tais atividades são as revisões técnicas e os walkthroughs.

## 1.3. Alguns termos no jargão

Nesta seção procuramos identificar alguns termos importantes e que ajudarão o leitor a melhor compreender os textos dos próximos capítulos.

Na seção anterior dissemos que diversos “problemas” podem emergir durante o desenvolvimento de software e, em seguida, nos referimos a esses problemas como “erros”. A literatura tradicional estabelece significados específicos para este e outros termos relacionados como: falha, defeito, erro, engano. Vamos procurar identificar cada um deles.

Definimos **“defeito”** (do inglês, **fault**) como sendo um passo, processo ou definição de dados incorretos e **“engano”** (**mistake**) como a ação humana que produz um defeito. Assim, esses dois conceitos são estáticos, pois estão associados a um determinado programa ou modelo e não dependem de uma execução particular.

O estado de um programa ou, mais precisamente, da execução de um programa em determinado instante, é dado pelo valor da memória (ou das variáveis do programa) e do apontador de instruções. A existência de um defeito pode ocasionar a ocorrência de um **“erro”** (**error**) durante uma execução do programa, que se caracteriza por um estado inconsistente ou inesperado. Tal estado pode levar a uma **“falha”** (**failure**), ou seja, pode fazer com que o resultado produzido pela execução seja diferente do resultado esperado.

Note-se que essas definições não são seguidas o tempo todo nem são unanimidade entre os pesquisadores e engenheiros de software, principalmente em situações informais do dia-a-dia. Em particular, utiliza-se “erro” de uma maneira bastante flexível, muitas vezes significando defeito, erro ou até falha.

O “domínio” de entrada de um programa P, denotado por D(P), é o conjunto de todos os possíves valores que podem ser utilizados para executar P. Por exemplo, vamos tomar um programa que recebe como parâmetros de entrada dois números inteiros x e y, com y ≥ 0, e computa o valor de x y , indicando um erro caso os argumentos estejam fora do intervalo especificado. O domínio de entrada deste programa é formado por todos os possíveis pares de números inteiros (x, y). Da mesma forma, pode-se estabelecer o domínio de saída do programa, que é o conjunto de todos os possíveis resultados produzidos pelo programa. No nosso exemplo, seria o conjunto de números inteiros e mensagens de erro produzidos pelo programa.

Um “dado de teste” para um programa P é um elemento do domínio de entrada de P. Um “caso de teste” é um par formado por um dado de teste mais o resultado esperado para a execução do programa com aquele dado de teste. Por exemplo, no programa que computa x y , teríamos os seguintes casos de teste: {(2, 3) → 8}, {(4, 3) → 64}, {(3, −1) → “Erro”}. Ao conjunto de todos os casos de teste usados durante uma determinada atividade de teste costuma-se chamar “conjunto de teste” ou “conjunto de casos de teste”.

Definido um conjunto de casos de teste T, executa-se o programa em teste com T e verifica-se qual é o resultado obtido. Se o resultado produzido pela execução de P coincide com o resultado esperado, então nenhum erro foi identificado. Se, para algum caso de teste, o resultado obtido difere do resultado esperado, então um defeito foi revelado. Como sugere a Figura 1.1, em geral, fica por conta do testador, baseado na especificação do programa (S(P)) ou em qualquer forma de documento que defina seu comportamento, a análise sobre a correção de uma execução.

## 1.4. Fases da Atividade de Teste

A atividade de teste é complexa. São diversos os fatores que podem colaborar para a ocorrência de erros. Por exemplo, a utilização de um algoritmo incorreto para computar o valor das mensalidades a serem pagas para um empréstimo ou a não-utilização de uma política de segurança em alguma funcionalidade do software são dois tipos distintos de engano e, de certa forma, encontram-se em níveis diferentes de abstração. O primeiro tipo de erro provavelmente está confinado a uma função ou rotina que implementa de forma incorreta uma dada funcionalidade. No segundo caso, mesmo que exista uma certa política de segurança implementada de maneira correta, é preciso verificar se todos os pontos nos quais essa política deveria ser aplicada fazem-no de maneira correta.

Por isso, a atividade de teste é dividida em fases com objetivos distintos. De uma forma geral, podemos estabelecer como fases o **teste de unidade**, o **teste de integração** e o **teste de sistemas**. O teste de unidade tem como foco as menores unidades de um programa, que podem ser funções, procedimentos, métodos ou classes. Nesse contexto, espera-se que sejam identificados erros relacionados a algoritmos incorretos ou mal implementados, estruturas de dados incorretas, ou simples erros de programação. Como cada unidade é testada separadamente, o teste de unidade pode ser aplicado à medida que ocorre a implementação das unidades e pelo próprio desenvolvedor, sem a necessidade de dispor-se do sistema totalmente finalizado.

No teste de integração, que deve ser realizado após serem testadas as unidades individualmente, a ênfase é dada na construção da estrutura do sistema. À medida que as diversas partes do software são colocadas para trabalhar juntas, é preciso verificar se a interação entre elas funciona de maneira adequada e não leva a erros. Também nesse caso é necessário um grande conhecimento das estruturas internas e das interações existentes entre as partes do sistema e, por isso, o teste de integração tende a ser executado pela própria equipe de desenvolvimento.

Depois que se tem o sistema completo, com todas as suas partes integradas, inicia-se o teste de sistema. O objetivo é verificar se as funcionalidades especificadas nos documentos de requisitos estão todas corretamente implementadas. Aspectos de correção, completude e coerência devem ser explorados, bem como requisitos não funcionais como segurança, performance e robustez. Muitas organizações adotam a estratégia de designar uma equipe independente para realizar o teste de sistemas.

Além dessas três fases de teste, destacamos, ainda, o que se costuma chamar de “teste de regressão”. Esse tipo de teste não se realiza durante o processo “normal” de desenvolvimento, mas sim durante a manutenção do software. A cada modificação efetuada no sistema, após a sua liberação, corre-se o risco de que novos defeitos sejam introduzidos. Por esse motivo, é necessário, após a manutenção, realizar testes que mostrem que as modificações efetuadas estão corretas, ou seja, que os novos requisitos implementados (se for esse o caso) funcionam como o esperado e que os requisitos anteriormente testados continuam válidos.

Independentemente da fase de teste, existem algumas etapas bem definidas para a execução da atividade de teste. São elas: 1) planejamento; 2) projeto de casos de teste; 3) execução; e 4) análise.

## 1.5. Técnicas e Critérios de Teste

Podemos notar na Figura 1.1 que, ao se testar um programa P, selecionam-se alguns pontos específicos do domínio D(P) para a execução de P. Idealmente, o programa em teste deveria ser executado com todos os elementos de D(P) para garantir que não contém defeitos. Em geral, tal abordagem é infactível por causa da cardinalidade de D(P). Por exemplo, no programa que computa x y , o domínio é formado por todos os pares de números inteiros (x, y), o que produz um conjunto de cardinalidade 2^n ∗ 2^n , onde n é o número de bits usado para representar um número inteiro. Em uma arquitetura com 32 bits isso representa 2^64 = 18446744073709551616. Se cada caso de teste pudesse ser executado em 1 milissegundo, precisaríamos de 5.849.424 séculos para executá-los todos.

Assim, é importante procurarmos formas de utilizar apenas um subconjunto reduzido de D(P) para a execução de P, mas que tenha alta probabilidade de revelar a presença de defeitos caso eles existam. A idéia central para isso é a de “subdomínios” de teste. Um subdomínio de D(P) é um subconjunto do domínio de entrada que contém dados de teste “semelhantes”. Por exemplo, podemos argumentar que os casos de teste {(2, −1), “Erro”} e {(2, −2), “Erro”} são semelhantes, pois, qualquer que seja a implementação, intuitivamente espera-se que P se comporte de maneira semelhante para ambos os casos de teste. Nesse caso, não seria necessário executar o programa em teste com os dois casos de teste. Generalizando, qualquer caso de teste da forma {(x, y), “Erro”} em que x > 0 e y < 0 se comporta do mesmo modo ou, em outras palavras, pertence a um mesmo subdomínio de D(P); por isso, basta executar P com apenas um deles. Caso isso seja feito para todos os subdomínios de D(P), consegue-se um conjunto de T bastante reduzido em relação a D(P) mas que, de certa maneira, representa cada um dos seus elementos.

Na essência, existem duas formas de se procurar selecionar elementos de cada um dos subdomínios de teste. A primeira é o que se chama de “teste aleatório”, em que um grande número de casos de teste é selecionado aleatoriamente, de modo que, probabilisticamente, se tenha uma boa chance de que todos os subdomínios estejam representados no conjunto de teste T. A segunda é o “teste de partição” ou, mais corretamente, “teste de subdomínios”, no qual se procura estabelecer quais são os subdomínios a serem utilizados e, então, selecionam-se os casos de teste em cada subdomínio. Cada uma dessas abordagens tem suas vantagens e desvantagens. Neste livro, as técnicas apresentadas se encaixam na segunda estratégia, não sendo abordado o teste aleatório.

Em relação ao teste de subdomínios, fica a questão de como identificar os subdomínios para, então, fazer a seleção de casos de teste. O que ocorre, na prática, é que são estabelecidas certas “regras” para identificar quando dados de teste devem estar no mesmo subdomínio ou não. Em geral, são definidos “requisitos de teste” como, por exemplo, executar uma determinada estrutura do programa. Os dados de teste que satisfazem esse requisito pertencem ao mesmo subdomínio.

Dessa forma, dependendo do tipo de regra que se utiliza, são obtidos subdomínios diferentes e, portanto, conjuntos diferentes de teste. Tais regras são chamadas “critérios de teste”. Podemos identificar três tipos diferentes de critérios: funcionais, estruturais e baseados em defeitos (ou erros). O que diferencia cada uma dessas técnicas é o tipo de informação utilizada para estabelecer os subdomínios. Um conjunto de teste que satisfaz todos os requisitos de um critério de teste C, ou seja, que tem pelo menos um caso de teste para cada subdomínio determinado por C, é dito “adequado” a C ou “C-adequado”

## 1.6. Características e Limitações

Um único critério de teste é ideal: aquele que estabelece que cada subdomínio de D(P ) é unitário, ou seja, cada dado de teste compõe isoladamente o próprio domínio. Sendo assim, todos os elementos do domínio devem ser selecionados para o teste. É o que chamamos de “teste exaustivo”. Como vimos anteriormente, o teste exaustivo é, em geral, infactível.

Isso significa que, na prática, é impossível mostrar que um programa está correto por meio de teste. Isso porque, aliado a algumas limitações teóricas citadas a seguir, ao se escolher um subconjunto de D(P) corre-se sempre o risco de deixar de fora algum caso de teste que poderia revelar a presença de um defeito.

Por isso costumamos dizer que o objetivo da atividade de teste não é, como podem pensar muitos, mostrar que um programa está correto. Ao invés disso, o objetivo é mostrar a presença de defeitos caso eles existam. Quando a atividade de teste é realizada de maneira criteriosa e embasada tecnicamente, o que se tem é uma certa “confiança” de que se comporta corretamente para grande parte do seu domínio de entrada.

Não existe, em princípio, nenhuma restrição sobre o tipo de critérios de teste que pode ser definido e utilizado. Entretanto, a fim de se obter um nível mínimo de qualidade para os conjuntos adequados a um critério C para um programa P, deve-se requerer que:

- exista um conjunto C-adequado que seja finito e, de preferência, de baixa cardinalidade;
- do ponto de vista do fluxo de execução, um conjunto que seja C-adequado deve garantir que cada comando de P seja executado, pelo menos, uma vez;
- do ponto de vista da utilização das variáveis, cada atribuição de valor a uma variável deve ter seu valor verificado por um caso de teste que execute o trecho do programa que vai do ponto em que a variável recebe esse valor até um ponto do programa em que esse valor é utilizado.

## 1.7. Temas relacionados

Vamos abordar, rapidamente, alguns temas importantes, relacionados ao teste de software e que serão tratados na parte final deste livro. Muitos confundem, talvez com certa razão, depuração e teste de software. Embora fortemente relacionadas, são duas atividades diversas. O teste de software tem como objetivo, como vimos anteriormente, mostrar que o software não funciona como o esperado, ou seja, possui defeitos. A depuração, por sua vez, deve localizar as causas que levaram o software a falhar e indicar como ele deve ser corrigido. Por muito tempo, assim como acontecia com a atividade de teste, a depuração baseou-se principalmente na habilidade e na experiência das pessoas encarregadas dessa tarefa, sem que fossem utilizadas técnicas sistemáticas. Recentemente, diversos esforços têm sido observados visando a desenvolver técnicas para melhorar a qualidade e a produtividade nessa atividade. Muitas delas, inclusive, beneficiam-se de informações geradas durante o teste, como é mostrado no Capítulo 12.

Um ponto importante para o sucesso no teste de um software é a automatização. Diversos tipos de ferramentas de teste têm sido utilizados para buscar aumentar a produtividade nessa atividade, que tende a ser extremamente dispendiosa. Em particular, no projeto de casos de teste torna-se essencial a existência de uma ferramenta de suporte que compute os requisitos de teste de um determinado critério e verifique a adequação de um conjunto de teste. Ainda assim, muito trabalho humano deve ser empregado para criar casos de teste que sejam adequados ao critério utlizado. Nesse sentido, técnicas para geração automática de casos de teste são bastante desejadas para permitir a automatização também desse aspecto do teste. É claro, porém, que não existe um procedimento geral que permita a geração de conjuntos adequados a qualquer critério de teste. Na prática, técnicas específicas são projetadas para cada critério de teste. As técnicas de geração de dados de teste são discutidas com detalhes no Capítulo 11.

Podemos definir confiabilidade como a tendência de um software em operar de maneira correta. Certamente essa é uma das mais importantes,se não a mais importante,  características desejadas de um software. Assim, a análise de confiabilidade de software, ou seja, procurar medir de forma objetiva essa característica tornou-se um fator de extrema importância nas organizações que desenvolvem software de maneira profissional. Por outro lado, essa é uma atividade que está longe de ser trivial e demanda técnicas específicas. A análise de confiabilidade baseia-se em conceitos de métricas, medidas e modelos matemáticos que são usados para avaliar o comportamento do software. Por exemplo, medindo-se a freqüência de falhas em um determinado período de tempo e aplicando-se um modelo de falhas pode-se estimar seu nível de confiabilidade e prever seu comportamento futuro. O Capítulo 13 apresenta com detalhes esses conceitos e discute diversos modelos de falhas existentes na literatura.

